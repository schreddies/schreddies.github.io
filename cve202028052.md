# Authentication bypass in crytpography library
Vulnerability was found by the Synopsys CyRC researchers in the Bouncy Castle java library, in OpenBSDBcrypt class - see [following article](https://www.synopsys.com/blogs/software-security/cve-2020-28052-bouncy-castle/) for more info from their side.

## Intro
As it was already written in that post, the issue was with implementation method `doCheckPassword`- method that checks password against a 60 character Bcrypt string. Let's dive into that and see what was the core issue and how it was fixed.

## Analysis
In file `core/src/main/java/org/bouncycastle/crypto/generators/OpenBSDBCrypt.java` we can directly go to method `doCheckPassword`, where we have couple major checks. Whether the Bcrypt string is really Bcrypt string, and if cost factor is from proper range. Nothing special, nothing wrong, just `if's`. But revelant to our issue, and already mentioned, line 268, states, that only string with excatly 60 characters will be analysed. 
```java
if (sLength != 60)
```
And that's true/ And it works like that, but let's remember the number `60`. 

Then, in line 307, the Bcrypt hash `newBcryptString` is generated from password and salt and in following lines will checked against the provided hash `bcryptString`. And here we had vulnerbility:

```java 
        boolean isEqual = sLength == newBcryptString.length();
        for (int i = 0; i != sLength; i++)
        {
            isEqual &= (bcryptString.indexOf(i) == newBcryptString.indexOf(i));
        }
        return isEqual;
```
In first line of code block, there was declaration of a variable with primitive boolean, initialization with the `sLength` value and comparing it with an int value from length of `newBcryptString` using the == operator. The result should be true!
And then there is the `for` loop, where the first interesting bit is the second statment, where the `sLength` is used. As you migth remember: 60!
Now I would like to focus a little bit on the `indexOf`. Yup, there is no more code, so probably here we have the issue. 
For the documentation: `Returns the index within this string of the first occurrence of the specified character.`. As in the code, there is one parameter of the method `indexOf`, and it is `i`, which basically is integer in range from 0 to 59 we are going, at some point have following operation:
```
  isEqual &= (bcryptString.indexOf(33) == newBcryptString.indexOf(33));
```
And you migth ask, what's the outcome? This operation is checking if index of first occurance of `!` in both string is the same. And that's the problem. Because, also from documentation the parameter, the `i`, of method `indexOf` is taken as Unicode. In other words, this part of code checking if first occurance of unicode characters from 0 to 59 is the same for both strings. 

## Let's get back - how the Bcrypt string looks like.











